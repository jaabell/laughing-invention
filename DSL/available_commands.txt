add acceleration field # <.> ax = <accel> ay = <accel> az = <aaccel> ;
add constraint equal dof with master node # <.> and slave node # <.> dof to constrain <.>;
add damping # <.> to element # <.>;
add damping # <.> to node # <.>;
add damping # <.> type Caughey3rd with a0 = <time> a1 = <1/time> a2 = <.> stiffness_to_use = <Initial_Stiffness|Current_Stiffness|Last_Committed_Stiffness>;
add damping # <.> type Caughey4th with a0 = <time> a1 = <1/time> a2 = <.> a3 = <.> stiffness_to_use = <Initial_Stiffness|Current_Stiffness|Last_Committed_Stiffness>;
add damping # <.> type Rayleigh with a0 = <time> a1 = <1/time> stiffness_to_use = <Initial_Stiffness|Current_Stiffness|Last_Committed_Stiffness>;
add domain reduction method loading # <.> hdf5_file = <string>;
add element # <.> type 20NodeBrick using <.> Gauss points each direction with nodes (<.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>) use material # <.>;
add element # <.> type 20NodeBrick with nodes (<.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>) use material # <.>;
add element # <.> type 20NodeBrick_elastic with nodes (<.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>) use material # <.>;
add element # <.> type 20NodeBrick_upU with nodes (<.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>) use material # <.> and porosity = <.> alpha = <.>  rho_s = <M/L^3>  rho_f = <M/L^3> k_x = <L^3T/M>  k_y = <L^3T/M>  k_z = <L^3T/M>  K_s = <stress> K_f = <stress>;
add element # <.> type 27NodeBrick using <.> Gauss points each direction with nodes (<.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>) use material # <.>;
add element # <.> type 27NodeBrick with nodes (<.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>) use material # <.>;
add element # <.> type 27NodeBrick_elastic with nodes (<.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>) use material # <.>;
add element # <.> type 27NodeBrickLT with nodes (<.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>) use material # <.>;
add element # <.> type 3NodeShell_ANDES with nodes (<.>, <.>, <.>) use material # <.> thickness = <l> ;
add element # <.> type 4NodeShell_ANDES with nodes (<.>, <.>, <.>, <.>) use material # <.> thickness = <l> ;
add element # <.> type 4NodeShell_MITC4 with nodes (<.>, <.>, <.>, <.>) use material # <.> thickness = <L>;
add element # <.> type 4NodeShell_NewMITC4 with nodes (<.>, <.>, <.>, <.>) use material # <.> thickness = <L>;
add element # <.> type 8NodeBrick using <.> Gauss points each direction with nodes (<.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>) use material # <.>;
add element # <.> type 8NodeBrick with nodes (<.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>) use material # <.>;
add element # <.> type 8NodeBrick_elastic with nodes (<.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>) use material # <.>;
add element # <.> type 8NodeBrick_up with nodes (<.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>) use material # <.> porosity = <.> alpha = <.>  rho_s = <M/L^3>  rho_f = <M/L^3> k_x = <L^3T/M>  k_y = <L^3T/M>  k_z = <L^3T/M>  K_s = <stress> K_f = <stress>;
add element # <.> type 8NodeBrick_upU with nodes (<.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>) use material # <.> porosity = <.> alpha = <.>  rho_s = <M/L^3>  rho_f = <M/L^3> k_x = <L^3T/M>  k_y = <L^3T/M>  k_z = <L^3T/M>  K_s = <stress> K_f = <stress>;
add element # <.> type 8NodeBrickLT with nodes (<.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>) use material # <.>;
add element # <.> type beam_9dof_elastic with nodes (<.>, <.>) cross_section = <area> elastic_modulus = <F/L^2> shear_modulus = <F/L^2> torsion_Jx = <length^4> bending_Iy = <length^4> bending_Iz = <length^4> mass_density = <M/L^3>  xz_plane_vector = (<.>, <.>, <.> ) joint_1_offset = (<L>, <L>, <L> ) joint_2_offset = (<L>, <L>, <L> );
add element # <.> type beam_displacement_based with nodes (<.>, <.>) with # <.> integration_points use section # <.> mass_density = <M/L^3> IntegrationRule = "" xz_plane_vector = (<.>, <.>, <.> ) joint_1_offset = (<L>, <L>, <L> ) joint_2_offset = (<L>, <L>, <L> );
add element # <.> type beam_elastic with nodes (<.>, <.>) cross_section = <area> elastic_modulus = <F/L^2> shear_modulus = <F/L^2> torsion_Jx = <length^4> bending_Iy = <length^4> bending_Iz = <length^4> mass_density = <M/L^3>  xz_plane_vector = (<.>, <.>, <.> ) joint_1_offset = (<L>, <L>, <L> ) joint_2_offset = (<L>, <L>, <L> );
add element # <.> type beam_elastic_lumped_mass with nodes (<.>, <.>) cross_section = <area> elastic_modulus = <F/L^2> shear_modulus = <F/L^2> torsion_Jx = <length^4> bending_Iy = <length^4> bending_Iz = <length^4> mass_density = <M/L^3>  xz_plane_vector = (<.>, <.>, <.> ) joint_1_offset = (<L>, <L>, <L> ) joint_2_offset = (<L>, <L>, <L> );
add element # <.> type FrictionalPenaltyContact with nodes (<.>, <.>) normal_stiffness = <F/L> tangential_stiffness = <F/L> normal_damping = <F/L> tangential_damping = <F/L>  friction_ratio = <.>  contact_plane_vector = (<.>, <.>, <.> );
add element # <.> type ShearBeamLT with nodes (<.>, <.>) cross_section = <l^2> use material # <.>;
add element # <.> type truss with nodes (<.>, <.>) use material # <.> cross_section = <length^2> mass_density = <M/L^3> ;
add element # <.> type variable_node_brick_8_to_27 using <.> Gauss points each direction with nodes (<.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>, <.>) use material # <.>;
add imposed motion # <.> to node # <.> dof DOFTYPE displacement_scale_unit = <displacement> displacement_file = "filename" velocity_scale_unit = <velocity> velocity_file = "filename" acceleration_scale_unit = <acceleration> acceleration_file = "filename";
add imposed motion # <.> to node # <.> dof DOFTYPE time_step = <t> displacement_scale_unit = <length> displacement_file = "filename" velocity_scale_unit = <velocity> velocity_file = "filename" acceleration_scale_unit = <acceleration> acceleration_file = "filename";
add load # <.> to element # <.> type self_weight use acceleration field # <.>;
add load # <.> to element # <.> type surface at nodes (<.> , <.> , <.> , <.>) with magnitude <.>;
add load # <.> to element # <.> type surface at nodes (<.> , <.> , <.> , <.>) with magnitudes (<.> , <.> , <.> , <.>);
add load # <.> to element # <.> type surface at nodes (<.> , <.> , <.> , <.>, <.>, <.>, <.>, <.>) with magnitude <.>;
add load # <.> to element # <.> type surface at nodes (<.> , <.> , <.> , <.>, <.>, <.>, <.>, <.>) with magnitudes (<.> , <.> , <.> , <.>, <.>, <.>, <.>, <.>);
add load # <.> to element # <.> type surface at nodes (<.> , <.> , <.> , <.>, <.>, <.>, <.>, <.>, <.>) with magnitude <.>;
add load # <.> to element # <.> type surface at nodes (<.> , <.> , <.> , <.>, <.>, <.>, <.>, <.>, <.>) with magnitudes (<.> , <.> , <.> , <.>, <.>, <.>, <.>, <.>, <.>);
add load # <.> to node # <.> type from_reactions;
add load # <.> to node # <.> type linear FORCETYPE = <force or moment>; //FORCETYPE = Fx Fy Fz Mx My Mz F_fluid_x F_fluid_y F_fluid_z
add load # <.> to node # <.> type path_series FORCETYPE = <force or moment> time_step = <time> series_file = "STRING";
add load # <.> to node # <.> type path_time_series FORCETYPE = <force or moment> series_file = "STRING";
add load # <.> to node # <.> type self_weight use acceleration field # <.>;
add mass to node # <.> mx = <mass> my = <mass> mz = <mass> Imx = <mass*length^2> Imy = <mass*length^2> Imz = <mass*length^2>;
add mass to node # <.> mx = <mass> my = <mass> mz = <mass>;
add material # <.> type camclay mass_density = <M/L^3> reference_void_ratio = <.> critical_stress_ratio_M = <.> lambda = <.> kappa = <.> poisson_ratio = <.> minimum_bulk_modulus = <F/L^2> initial_mean_pressure = <F/L^2> algorithm = <explicit|implicit>  number_of_subincrements = <.> maximum_number_of_iterations = <.> tolerance_1 = <.> tolerance_2 = <.>;
add material # <.> type camclay_accelerated mass_density = <M/L^3> reference_void_ratio = <.> critical_stress_ratio_M = <.> lambda = <.> kappa = <.> poisson_ratio = <.> minimum_bulk_modulus = <F/L^2> pressure_reference_p0 = <F/L^2> initial_confining_stress = <F/L^2>  maximum_number_of_iterations = <.> tolerance_1 = <.> tolerance_2 = <.>;
add material # <.> type druckerprager_isotropic_hardening mass_density = <M/L^3> elastic_modulus = <F/L^2>  poisson_ratio = <.> druckerprager_angle = <F/L^2> isotropic_hardening_rate = <F/L^2> initial_confining_stress = <F/L^2> algorithm = <explicit|implicit>  number_of_subincrements = <.> maximum_number_of_iterations = <.> tolerance_1 = <.> tolerance_2 = <.>;
add material # <.> type druckerprager_isotropic_hardening_accelerated mass_density = <M/L^3> elastic_modulus = <F/L^2>  poisson_ratio = <.> druckerprager_angle = <F/L^2> isotropic_hardening_rate = <F/L^2> initial_confining_stress = <F/L^2> maximum_number_of_iterations = <.> tolerance_1 = <.> tolerance_2 = <.>;
add material # <.> type druckerprager_kinematic_hardening  mass_density = <M/L^3> elastic_modulus = <F/L^2>  poisson_ratio = <.> druckerprager_angle = <F/L^2> armstrong_frederick_ha = <F/L^2> armstrong_frederick_cr = <F/L^2> initial_confining_stress = <F/L^2> algorithm = <explicit|implicit>  number_of_subincrements = <.> maximum_number_of_iterations = <.> tolerance_1 = <.> tolerance_2 = <.>;
add material # <.> type druckerprager_kinematic_hardening_accelerated  mass_density = <M/L^3> elastic_modulus = <F/L^2>  poisson_ratio = <.> druckerprager_angle = <F/L^2> armstrong_frederick_ha = <F/L^2> armstrong_frederick_cr = <F/L^2> initial_confining_stress = <F/L^2> maximum_number_of_iterations = <.> tolerance_1 = <.> tolerance_2 = <.>;
add material # <.> type druckerprager_perfectly_plastic  mass_density = <M/L^3> elastic_modulus = <F/L^2>  poisson_ratio = <.> druckerprager_angle = <F/L^2> initial_confining_stress = <F/L^2> algorithm = <explicit|implicit>  number_of_subincrements = <.> maximum_number_of_iterations = <.> tolerance_1 = <.> tolerance_2 = <.>;
add material # <.> type druckerprager_perfectly_plastic_accelerated  mass_density = <M/L^3> elastic_modulus = <F/L^2>  poisson_ratio = <.> druckerprager_angle = <F/L^2> initial_confining_stress = <F/L^2> maximum_number_of_iterations = <.> tolerance_1 = <.> tolerance_2 = <.>;
add material # <.> type DruckerPragerLT mass_density = <M/L^3> elastic_modulus = <F/L^2> poisson_ratio = <.> druckerprager_k = <F/L^2> kinematic_hardening_rate = <F/L^2> isotropic_hardening_rate = <F/L^2> ;
add material # <.> type linear_elastic_crossanisotropic mass_density = <mass_density> elastic_modulus_horizontal = <F/L^2> elastic_modulus_vertical = <F/L^2> poisson_ratio_h_v = <.> poisson_ratio_h_h = <.> shear_modulus_h_v = <F/L^2>;
add material # <.> type linear_elastic_isotropic_3d mass_density = <M/L^3> elastic_modulus = <F/L^2> poisson_ratio = <.>;
add material # <.> type linear_elastic_isotropic_3d_LT mass_density = <M/L^3> elastic_modulus = <F/L^2> poisson_ratio = <.>;
add material # <.> type New_PisanoLT mass_density '=' exp elastic_modulus_1atm = <F/L^2> poisson_ratio = <.> M_in = <.> kd_in = <.> xi_in = <.> h_in = <.> m_in = <.> initial_confining_stress = <F/L^2> n_in = <.> a_in = <.> eplcum_cr_in = <.>;
add material # <.> type sanisand2004 mass_density = <M/L^3> e0 = <.> sanisand2004_G0 = <.> poisson_ratio = <.> sanisand2004_Pat = <stress>  sanisand2004_p_cut = <.>  sanisand2004_Mc = <.>  sanisand2004_c = <.> sanisand2004_lambda_c = <.> sanisand2004_xi = <.>  sanisand2004_ec_ref = <.>  sanisand2004_m = <.>  sanisand2004_h0 = <.> sanisand2004_ch = <.>  sanisand2004_nb = <.> sanisand2004_A0 = <.> sanisand2004_nd = <.> sanisand2004_z_max = <.>  sanisand2004_cz = <.> initial_confining_stress = <stress>  algorithm = <explicit|implicit>  number_of_subincrements = <.>  maximum_number_of_iterations = <.>  tolerance_1 = <.>  tolerance_2 = <.>;
add material # <.> type sanisand2008 mass_density = <M/L^3>  e0 = <.>  sanisand2008_G0 = <.>  sanisand2008_K0 = <.> sanisand2008_Pat = <stress> sanisand2008_k_c = <.>  sanisand2008_alpha_cc = <.> sanisand2008_c = <.>  sanisand2008_xi = <.>  sanisand2008_lambda = <.>  sanisand2008_ec_ref = <.>  sanisand2008_m = <.>  sanisand2008_h0 = <.>  sanisand2008_ch = <.>  sanisand2008_nb = <.>  sanisand2008_A0 = <.> sanisand2008_nd = <.>  sanisand2008_p_r = <.>  sanisand2008_rho_c = <.>  sanisand2008_theta_c = <.>  sanisand2008_X = <.>  sanisand2008_z_max = <.>  sanisand2008_cz = <.>  sanisand2008_p0 = <stress>  sanisand2008_p_in = <.>  algorithm = <explicit|implicit>  number_of_subincrements = <.>  maximum_number_of_iterations = <.>  tolerance_1 = <.>  tolerance_2 = <.>;
add material # <.> type uniaxial_concrete02 compressive_strength = <F/L^2> strain_at_compressive_strength = <.> crushing_strength = <F/L^2>  strain_at_crushing_strength = <.> lambda = <.> tensile_strength = <F/L^2> tension_softening_stiffness = <F/L^2>;
add material # <.> type uniaxial_elastic elastic_modulus = <F/L^2> viscoelastic_modulus = <mass / length / time> ;
add material # <.> type uniaxial_steel01 yield_strength = <F/L^2> elastic_modulus = <F/L^2> strain_hardening_ratio = <.>  a1 = <.>  a2 = <.>  a3 = <>  a4 = <.> ;
add material # <.> type uniaxial_steel02 yield_strength = <F/L^2> elastic_modulus = <F/L^2> strain_hardening_ratio = <.> R0 = <.> cR1 = <.> cR2 = <.>  a1 = <.>  a2 = <.>  a3 = <>  a4 = <.> ;
add material # <.> type vonmises_isotropic_hardening mass_density = <M/L^3> elastic_modulus = <F/L^2> poisson_ratio = <.> von_mises_radius = <F/L^2> isotropic_hardening_rate = <F/L^2> initial_confining_stress = <F/L^2> algorithm = <explicit|implicit> number_of_subincrements = <.> maximum_number_of_iterations = <.> tolerance_1 = <.> tolerance_2 = <.>;
add material # <.> type vonmises_isotropic_hardening_accelerated mass_density = <M/L^3> elastic_modulus = <F/L^2> poisson_ratio = <.> von_mises_radius = <F/L^2> isotropic_hardening_rate = <F/L^2> initial_confining_stress = <F/L^2>  maximum_number_of_iterations = <.> tolerance_1 = <.> tolerance_2 = <.>;
add material # <.> type vonmises_kinematic_hardening mass_density = <M/L^3> elastic_modulus = <F/L^2> poisson_ratio = <.> von_mises_radius = <F/L^2> armstrong_frederick_ha = <F/L^2> armstrong_frederick_cr = <F/L^2> initial_confining_stress = <F/L^2> algorithm = <explicit|implicit> number_of_subincrements = <.> maximum_number_of_iterations = <.> tolerance_1 = <.> tolerance_2 = <.>;
add material # <.> type vonmises_kinematic_hardening_accelerated mass_density = <M/L^3> elastic_modulus = <F/L^2> poisson_ratio = <.> von_mises_radius = <F/L^2> armstrong_frederick_ha = <F/L^2> armstrong_frederick_cr = <F/L^2> initial_confining_stress = <F/L^2> initial_confining_strain = <.> maximum_number_of_iterations = <.> tolerance_1 = <.> tolerance_2 = <.>;
add material # <.> type vonmises_linear_kinematic_hardening mass_density = <M/L^3> elastic_modulus = <F/L^2> poisson_ratio = <.> von_mises_radius = <F/L^2> kinematic_hardening_rate = <.> initial_confining_stress = <F/L^2> algorithm = <explicit|implicit> number_of_subincrements = <.> maximum_number_of_iterations = <.> tolerance_1 = <.> tolerance_2 = <.>;
add material # <.> type vonmises_linear_kinematic_hardening_accelerated mass_density = <M/L^3> elastic_modulus = <F/L^2> poisson_ratio = <.> von_mises_radius = <F/L^2> kinematic_hardening_rate = <.> initial_confining_stress = <F/L^2> initial_confining_strain = <.> maximum_number_of_iterations = <.> tolerance_1 = <.> tolerance_2 = <.>;
add material # <.> type vonmises_perfectly_plastic mass_density = <M/L^3> elastic_modulus = <F/L^2> poisson_ratio = <.> von_mises_radius = <F/L^2> initial_confining_stress = <F/L^2> algorithm = <explicit|implicit> number_of_subincrements = <.> maximum_number_of_iterations = <.> tolerance_1 = <.> tolerance_2 = <.>;
add material # <.> type vonmises_perfectly_plastic_accelerated mass_density = <M/L^3> elastic_modulus = <F/L^2> poisson_ratio = <.> von_mises_radius = <F/L^2> initial_confining_stress = <F/L^2>  maximum_number_of_iterations = <.> tolerance_1 = <.> tolerance_2 = <.>;
add material # <.> type vonmises_perfectly_plastic_LT mass_density = <M/L^3> elastic_modulus = <F/L^2> poisson_ratio = <.> von_mises_radius = <F/L^2> initial_confining_stress = <F/L^2>  maximum_number_of_iterations = <.> tolerance_1 = <.> tolerance_2 = <.>;
add material # <.> type VonMisesLT mass_density = <M/L^3> elastic_modulus = <F/L^2> poisson_ratio = <.> von_mises_radius = <F/L^2> kinematic_hardening_rate = <F/L^2> isotropic_hardening_rate = <F/L^2> ;
add node # <.> at (<length>,<length>,<length>)  with <.> dofs;
add section # <.> type Elastic_Membrane_Plate elastic_modulus = <F/L^2> poisson_ratio = <.> thickness = <length> mass_density = <M/L^3>;
add section # <.> type Membrane_Plate_Fiber thickness = <length> use material # <.>;
add single point constraint to node # <.> dof to constrain <dof_type> constraint value of <corresponding unit>;
check element # <.>;
check mesh filename;
compute reaction forces;
define algorithm With_no_convergence_check / Newton / Modified_Newton;
define convergence test Norm_Displacement_Increment / Energy_Increment / Norm_Unbalance tolerance = <length> maximum_iterations = <.> verbose_level = <0>|<1>|<2>;
define dynamic integrator Hilber_Hughes_Taylor with alpha = <.>;
define dynamic integrator Newmark with gamma = <.> beta = <.>;
define load factor increment <.>;
define solver ProfileSPD / UMFPack;
define static integrator displacement_control using node # <.> dof DOFTYPE increment <length>;
disable output;
enable element output;
enable output;
fix node # <.> dofs <.>;
fix node # <.> dofs all;
free node # <.> dofs <.>;
help;
if (.) { } else {};
if (.) { };
model name "name_string";
new loading stage "name_string";
output every <.> steps;
print <.> in <.>;
print <.>;
print domain;
print element # <.>;
print material # <.>;
print node # <.>;
remove constraint equaldof node # <.>;
remove element # <.>;
remove imposed motion # <.>;
remove load # <.>;
remove node # <.>;
set output compression level to <.>;
simulate <.> steps using static algorithm;
simulate <.> steps using transient algorithm time_step = <time>;
simulate <.> steps using variable transient algorithm time_step = <time> minimum_time_step = <time> maximum_time_step = <time> number_of_iterations = <.>;
simulate constitutive testing constant mean pressure triaxial strain control use material # <.> strain_increment_size = <.> maximum_strain = <.> number_of_times_reaching_maximum_strain = <.>;
simulate constitutive testing drained triaxial strain control use material # <.> strain_increment_size = <.> maximum_strain = <.> number_of_times_reaching_maximum_strain = <.>;
simulate constitutive testing undrained simple shear use material # <.> strain_increment_size = <.> maximum_strain = <.> number_of_times_reaching_maximum_strain = <.>;
simulate constitutive testing undrained triaxial stress control use material # <.> strain_increment_size = <.> maximum_strain = <.> number_of_times_reaching_maximum_strain = <.>;
simulate constitutive testing undrained triaxial use material # <.> strain_increment_size = <.> maximum_strain = <.> number_of_times_reaching_maximum_strain = <.>;
simulate using eigen algorithm number_of_modes = <.>;
ux uy uz Ux Uy Uz rx ry rz;
while (.) { };
whos;
